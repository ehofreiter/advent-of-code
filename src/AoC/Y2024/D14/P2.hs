module AoC.Y2024.D14.P2 where

import Control.Applicative ((<|>))
import Data.Attoparsec.Text qualified as P
import Data.ByteString qualified as BS
import Data.Char qualified as Char
import Data.Either
import Data.Functor
import Data.Functor.WithIndex
import Data.List qualified as List
import Data.List.Split qualified as Split
import Data.Map.Strict qualified as Map
import Data.Maybe qualified as Maybe
import Data.Sequence qualified as Seq
import Data.Set qualified as Set
import Data.Text qualified as T
import System.FilePath
import Text.Read qualified as Read
import Linear hiding (E)
import Data.Foldable

import AoC.Common
import AoC.CoordVec qualified as CV

type Loc = CV.Coord

day :: Int
day = 14

----------------------------------------

{-
Ultimately I ended up getting this one by noticing that every (72 + 101*n) steps, there was a
vertical anomaly, and every (31 + 103*m) steps, there was a horizontal anomaly. That was just
from browsing through the printouts generated by this program. The entire sequence of pictures
repeats every 101*103 = 10403 steps. So I suspected that the Easter egg Christmas tree would
show up when the two anomalies both hit. To find the index, solve:

  72 + 101*n (mod 10403) = 31 + 103*m (mod 10403)

I forget how to solve these, so I just brute-forced it:

  ghci> [(72 + 101*n) `mod` 10403 | n <- [1..103]] `List.intersect` [(31 + 103*m) `mod` 10403 | m <- [1..101]]
  [7344]

Printing the state after 7344 seconds yields the tree.
-}

type RoomSize = V2 Int

loadReal :: IO ([PosVel], RoomSize)
loadReal = do
  rows <- lines <$> readReal day
  pure (parseLine <$> rows, V2 101 103)

sim :: RoomSize -> [PosVel] -> [PosVel]
sim roomSize = fmap (simRobot roomSize)

simRobot :: RoomSize -> PosVel -> PosVel
simRobot = simRobotN 1

simN :: Int -> RoomSize -> [PosVel] -> [PosVel]
simN n roomSize = fmap (simRobotN n roomSize)

simRobotN :: Int -> RoomSize -> PosVel -> PosVel
simRobotN n roomSize robot = robot { pos = liftI2 mod (pos robot ^+^ vel robot ^* n) roomSize }

printRoom :: RoomSize -> [PosVel] -> IO ()
printRoom roomSize = traverse_ putStrLn . showRoom roomSize

showRoom :: RoomSize -> [PosVel] -> [String]
showRoom roomSize@(V2 rsx rsy) robots = do
  let posCounts = mkHistogram (pos <$> robots)
  [[countToChar . Maybe.fromMaybe 0 $ Map.lookup (V2 x y) posCounts | x <- [0..rsx-1]] | y <- [0..rsy-1]]

countToChar :: Int -> Char
countToChar i
  | i == 0 = '.'
  | i < 10 = head $ show i
  | i == 10 = 'A'
  | i == 11 = 'B'
  | i == 12 = 'C'
  | i == 13 = 'D'
  | i == 14 = 'E'
  | i == 15 = 'F'
  | otherwise = '#'

run :: IO ()
run = do
  (posVels, roomSize) <- loadReal
  -- See comment above for how I got the parameters for this computation.
  let result = head $ List.intersect
        [(72 + 101*n) `mod` 10403 | n <- [1..103]]
        [(31 + 103*m) `mod` 10403 | m <- [1..101]]
  answer result
  printRoom roomSize (simN result roomSize posVels)
  printToFile "data/output/day14/easter-egg" roomSize posVels result
  putStrLn "Starting REPL."
  let repl = do
        putStrLn "Enter command ('loop', 'write [filename] [stepNumFrom] [stepNumTo]', 'print [stepNum]', 'exit'):"
        cmd <- getLine
        case words cmd of
          ["loop"] ->
            loop roomSize posVels 0
          ["write", name, start, stop] -> do
            printToFileRange name roomSize posVels (read start, read stop)
            repl
          ["print", i] -> do
            printRoom roomSize (simN (read i) roomSize posVels)
            repl
          ["exit"] ->
            putStrLn "Bye!"
  repl

printToFile :: String -> RoomSize -> [PosVel] -> Int -> IO ()
printToFile file roomSize posVels i = do
  let filename = file <> "_" <> show i <> ".txt"
  writeFile filename $
    List.intercalate "\n" $
      showRoom roomSize (simN i roomSize posVels)
  putStrLn $ "Wrote file '" <> filename <> "'."

printToFileRange :: String -> RoomSize -> [PosVel] -> (Int, Int) -> IO ()
printToFileRange file roomSize posVels (start, stop) = do
  let steps = [start..stop]
      filename = file <> "_" <> show start <> "-" <> show stop <> ".txt"
  writeFile filename $ flip foldMap' [start..stop] $ \i ->
    List.intercalate "\n" $
      [ "Step " <> show i
      , replicate 101 '-'
      ] <> showRoom roomSize (simN i roomSize posVels)

loop :: RoomSize -> [PosVel] -> Int -> IO ()
loop roomSize posVels i = do
  putStrLn $ "Step " <> show i
  _ <- getLine
  printRoom roomSize posVels
  loop roomSize (sim roomSize posVels) (succ i)

data Quadrant = Q1 | Q2 | Q3 | Q4
  deriving (Bounded, Enum, Eq, Ord, Show)

quadrant :: RoomSize -> V2 Int -> Maybe Quadrant
quadrant roomSize@(V2 rsx rsy) (V2 x y)
  | x < hsx && y < hsy = Just Q1
  | x > hsx && y < hsy = Just Q2
  | x < hsx && y > hsy = Just Q3
  | x > hsx && y > hsy = Just Q4
  | otherwise = Nothing
 where
  halfRoomSize@(V2 hsx hsy) = liftI2 div (roomSize - V2 1 1) 2

data PosVel = PosVel { pos :: V2 Int, vel :: V2 Int }
  deriving (Eq, Ord, Show)

parseLine :: String -> PosVel
parseLine str =
  let [[px,py],[vx,vy]] = fmap (Split.splitOn "," . (!! 1) . Split.splitOn "=") $ words str
  in PosVel (V2 (read px) (read py)) (V2 (read vx) (read vy))
